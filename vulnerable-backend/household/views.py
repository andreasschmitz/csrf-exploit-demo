"""
Please note that all of this is just a quick and dirty implementation and a lot of this code is not safe for production.
"""
import json
from typing import Any

from django.db import transaction
from django.db.models import Case, Value, When
from django.http.response import HttpResponseRedirect, JsonResponse
from django.urls import reverse_lazy
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods
from django.views.generic import TemplateView

from .models import SleepingPlace


class HouseholdView(TemplateView):
    """A simple view that returns a list of all sleeping places, marking the one that is claimed by the user."""

    template_name = "household/index.html"

    def get_context_data(self, **kwargs: Any) -> dict[str, Any]:
        qs = SleepingPlace.objects.all().order_by("id")
        if self.request.user.is_anonymous:
            qs = qs.annotate(is_claimed_by_me=Value(0))
        else:
            qs = qs.annotate(
                is_claimed_by_me=Case(When(claimed_by=self.request.user.pk, then=Value(1)), default=Value(0))
            )
        kwargs["sleeping_places"] = qs
        return super().get_context_data(**kwargs)


# Note that we don't even have to add @csrf_exempt. You should never do state changes in a GET request.
@require_http_methods(["GET"])
def insecure_claim_sleeping_place(request, place_id):
    """
    Allows claiming sleeping places that are not occupied.

    This view is CSRF-vulnerable, because it performs state changes in a 'safe' method. According to the HTTP standard,
    safe methods (GET, HEAD, OPTIONS, and TRACE) must not do perform state changes.
    """
    response = HttpResponseRedirect(reverse_lazy("household:home"))
    if request.user.is_anonymous:
        return response

    qs = SleepingPlace.objects.select_for_update().filter(pk=place_id, claimed_by__isnull=True)
    with transaction.atomic():
        if not qs.exists():
            return response

        # Unassign myself from other sleeping place, if I occupy any
        SleepingPlace.objects.filter(claimed_by=request.user.pk).update(claimed_by=None)

        sleeping_place = qs.get()
        sleeping_place.claimed_by = request.user
        sleeping_place.save()

    return response


# Note that we don't even have to add @csrf_exempt. You should never do state changes in a GET request.
@require_http_methods(["GET"])
def insecure_get_leave_sleeping_place(request, place_id):
    """
    Leaves an occupied sleeping place.

    This view is CSRF-vulnerable, because it performs state changes in a 'safe' method. According to the HTTP standard,
    safe methods (GET, HEAD, OPTIONS, and TRACE) must not do perform state changes.
    """
    response = HttpResponseRedirect(reverse_lazy("household:home"))
    if request.user.is_anonymous:
        return response

    # Unassign myself from other sleeping place, if I occupy any
    SleepingPlace.objects.filter(pk=place_id, claimed_by=request.user.pk).update(claimed_by=None)

    return response


@csrf_exempt
@require_http_methods(["POST"])
def insecure_post_leave_sleeping_place(request):
    """
    Leaves an occupied sleeping place.

    This view is CSRF-vulnerable, because we disabled Django's CSRF protection by decorating the view with @csrf_exempt.
    """
    place_id = request.POST["place_id"]
    response = HttpResponseRedirect(reverse_lazy("household:home"))
    if place_id is None or request.user.is_anonymous:
        return response

    # Unassign myself from other sleeping place, if I occupy any
    SleepingPlace.objects.filter(pk=place_id, claimed_by=request.user.pk).update(claimed_by=None)

    return response


@csrf_exempt
@require_http_methods(["POST"])
def insecure_json_leave_sleeping_place(request, place_id):
    """
    Leaves an occupied sleeping place.

    This view is CSRF-vulnerable, because we disabled Django's CSRF protection by decorating the view with @csrf_exempt.

    Although endpoints that require JSON are typically not vulnerable to CSRF, this view is, because it accepts
    text/plain as Content-Type (simple request). Enforcing application/json as Content-Type would prevent that.
    """
    if place_id is None or request.user.is_anonymous:
        return JsonResponse({}, status=403)  # Forbidden

    data = json.loads(request.body)

    if "claimed_by" in data:
        # Unassign myself from other sleeping place, if I occupy any
        SleepingPlace.objects.filter(pk=place_id, claimed_by=request.user.pk).update(claimed_by=data["claimed_by"])

    return JsonResponse({}, status=204)
